<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>设计模式 | 日拱一卒，功不唐捐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="设计模式的六大原则开闭原则(Open Close Principle)开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。  里氏代换原则(Liskov Substitution Principle)里氏代换原则是面向对象设计的基本原则之一。 里氏代换">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://wanghe4096.github.io/2019/05/14/desgin-pattern/index.html">
<meta property="og:site_name" content="日拱一卒，功不唐捐">
<meta property="og:description" content="设计模式的六大原则开闭原则(Open Close Principle)开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。  里氏代换原则(Liskov Substitution Principle)里氏代换原则是面向对象设计的基本原则之一。 里氏代换">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-05T12:04:09.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式">
<meta name="twitter:description" content="设计模式的六大原则开闭原则(Open Close Principle)开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。  里氏代换原则(Liskov Substitution Principle)里氏代换原则是面向对象设计的基本原则之一。 里氏代换">
  
    <link rel="alternate" href="/atom.xml" title="日拱一卒，功不唐捐" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">日拱一卒，功不唐捐</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wanghe4096.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-desgin-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/desgin-pattern/" class="article-date">
  <time datetime="2019-05-13T16:00:00.000Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h2 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h2><p>开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。 </p>
<h2 id="里氏代换原则-Liskov-Substitution-Principle"><a href="#里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏代换原则(Liskov Substitution Principle)"></a>里氏代换原则(Liskov Substitution Principle)</h2><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h2 id="依赖倒转原则（Dependence-Inversion-Principle"><a href="#依赖倒转原则（Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则（Dependence  Inversion Principle)"></a>依赖倒转原则（Dependence  Inversion Principle)</h2><p>这个原则是， 使用多个隔离的接口， 比使用简单的接口要好。 它还有另外一个意思， 降低类之间的耦合度。 由此可见，其设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖， 降低耦合。 </p>
<h2 id="迪米特法则，又称最少知道原则（Demeter-Principle"><a href="#迪米特法则，又称最少知道原则（Demeter-Principle" class="headerlink" title="迪米特法则，又称最少知道原则（Demeter Principle)"></a>迪米特法则，又称最少知道原则（Demeter Principle)</h2><p>最少知道原则是指： 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h2 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h2><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<a id="more"></a>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><h2 id="单一职责的定义"><a href="#单一职责的定义" class="headerlink" title="单一职责的定义"></a>单一职责的定义</h2><ul>
<li>应该有且仅有一个原因引起类的变更 </li>
<li>单一职责原则要求一个接口只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情</li>
</ul>
<h2 id="单一职责的好处"><a href="#单一职责的好处" class="headerlink" title="单一职责的好处"></a>单一职责的好处</h2><ul>
<li><p>类型复杂性降低，实现什么职责都有清晰明确的定义</p>
</li>
<li><p>可读性提高，复杂性降低，自然可读性提高了</p>
</li>
<li><p>可维护性提高，可读性提高，那当然更容易维护了</p>
</li>
<li><p>变更上起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助</p>
</li>
</ul>
<h2 id="单一职责的难处"><a href="#单一职责的难处" class="headerlink" title="单一职责的难处"></a>单一职责的难处</h2><p>单一职责的难处是职责的划分。 一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责哪些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？ 这些都需要从实际工作场景中去考虑</p>
<h3 id="单一职责的例子"><a href="#单一职责的例子" class="headerlink" title="单一职责的例子"></a>单一职责的例子</h3><ul>
<li>非常典型的就是我们目现在的微服务的划分，比如我们按业务职责进行划分</li>
<li>日常开发中的接口、类、函数、甚至是变量的职责的定义，都需要遵守单一职责</li>
</ul>
<p>单一只责适用于接口、类，同时民适用于方法，什么意思呢？一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗</p>
<h2 id="单一职责中需要注意"><a href="#单一职责中需要注意" class="headerlink" title="单一职责中需要注意"></a>单一职责中需要注意</h2><p>单一职责原则提出一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。 </p>
<p>不能生搬硬套， 犯了意识形态的错误。 </p>
<h2 id="我单纯，我快乐"><a href="#我单纯，我快乐" class="headerlink" title="我单纯，我快乐"></a>我单纯，我快乐</h2><p>对接接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。 生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。 所以原则是死的， 人是活的，这句话很有道理。 </p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>对于单一职责，建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化 </p>
<h1 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h1><h2 id="继承的优点"><a href="#继承的优点" class="headerlink" title="继承的优点"></a>继承的优点</h2><ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； </li>
<li>提高代码的重用性； </li>
<li>子类可以形成父类，但又异于父类</li>
<li>提高代码的可扩展性，实现父类的方法,很多开源框架都是通过继承父类来完成的</li>
<li>提高产品或项目的开放性</li>
</ul>
<h2 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h2><ul>
<li>一定的侵入性。只要继承就必须拥有父类的所有性性和方法</li>
<li>降低代码的灵活性。 子类必须拥有父类的性性和方法，让子类自由的世界中多了些约速。这在我们用Go构建系统的时， 采用组合方式更为明显</li>
<li>增强了耦合性。 当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构</li>
</ul>
<h2 id="引入里氏代换原则"><a href="#引入里氏代换原则" class="headerlink" title="引入里氏代换原则"></a>引入里氏代换原则</h2><p>Golang 中是通过使用组合来实现继承，区别于java 中使用extends 字段来实现单一的继承规则，c++则采用多重继承的规则，即和go一样， 一个子类可以继承多个父类。 从整体来看， 利大于弊， 那么怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？ </p>
<h2 id="里氏代换原则的定义"><a href="#里氏代换原则的定义" class="headerlink" title="里氏代换原则的定义"></a>里氏代换原则的定义</h2><p>所有引用基类的地方必须能透明的使用其子类的方对象</p>
<p>通俗的讲， 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。 但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 </p>
<h2 id="里氏代换对于继承的规范"><a href="#里氏代换对于继承的规范" class="headerlink" title="里氏代换对于继承的规范"></a>里氏代换对于继承的规范</h2><ol>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的特性</li>
<li>覆盖或实现父类的方法时输入参数可以被放大</li>
<li>覆写或实现父类的方法时输出结果可以被缩小</li>
</ol>
<h3 id="子类必须完全实现父类的方法"><a href="#子类必须完全实现父类的方法" class="headerlink" title="子类必须完全实现父类的方法"></a>子类必须完全实现父类的方法</h3><p>我们在做系统设计时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏夫换原则。<br>作者在2.2节中， 举了一个CS游戏中的例子</p>
<h3 id="子类可以有自己的特性"><a href="#子类可以有自己的特性" class="headerlink" title="子类可以有自己的特性"></a>子类可以有自己的特性</h3><p>子类当然可以有自己的行为和外观，也不是方法和属性，在Go语言中，似乎只能用过接口组合的方式来实现。 否只能靠类型断言来处理。  但是里氏代换可正着用，而不能反着用。 大子类出现的地方，父类未必就可以胜任。</p>
<h3 id="覆盖或实现父类的方法时输入参数可以被放大"><a href="#覆盖或实现父类的方法时输入参数可以被放大" class="headerlink" title="覆盖或实现父类的方法时输入参数可以被放大"></a>覆盖或实现父类的方法时输入参数可以被放大</h3><p>方法中的输入参数称为前置条件，这是什么意思呢？大家做过Web Service开发应该知道有一个“契约优先” 也就是先定义WSDL接口，这种设计方法也叫做Design by<br>ontract (契约设计) ,与里氏替换原则有着异曲同工之秒。 契约制定了， 也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈。这里还是比较难理解的，</p>
<p>也就是子类代替父类传递到调用者中，子类的方法永远都不会被执行。 这是正确的， 如果你想让子类的方法运行，就必覆写父类的方法。 </p>
<h3 id="覆写或实现父类的方法时输出结果可以被缩小"><a href="#覆写或实现父类的方法时输出结果可以被缩小" class="headerlink" title="覆写或实现父类的方法时输出结果可以被缩小"></a>覆写或实现父类的方法时输出结果可以被缩小</h3><p>这是什么意思呢， 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏代换原则就要求S必须小于等于T， 也就是说， 要么S和T是同一个类型，要么S是T的子类，为什么呢？ 分两种情况， 如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 如果是重载， 则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下， 就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>采用里氏代替原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。 在实际项目中， 每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常的完美。 </p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在项目中，采用里氏替换原则时，尽量避免子类的“子性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了， 把子类当作父类来用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wanghe4096.github.io/2019/05/14/desgin-pattern/" data-id="cjyqpxmxj000jjffyyvss303i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/22/关于python/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          第1章 Python 入门（Day 1）
        
      </div>
    </a>
  
  
    <a href="/2019/05/14/mit_alogrithm_introduce/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">学习算法一些学习资料</div>
    </a>
  
</nav>

  
</article>






  <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
  
  
  var gitalk = new Gitalk({
    clientID: '676995b3169b0460f579',
    clientSecret: 'fcc2b957d39e2cf013d9289418e59a6e1740aa14',
    id: "设计模式",
    repo: 'wanghe4096.github.io',
    owner: 'wanghe4096',
    admin: 'wanghe4096',
    distractionFreeMode: 'true',
  })

  gitalk.render('gitalk-container')
</script>



</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/28/principle-of-ood/">再谈面象对向的设计原则</a>
          </li>
        
          <li>
            <a href="/2019/07/31/study-mongodb/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/30/api-design-guide/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/26/principle-of-design /">七条设计原则与应用实践</a>
          </li>
        
          <li>
            <a href="/2019/06/06/awesome-go-cn/">Go 资源大全中文版</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 王贺<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>