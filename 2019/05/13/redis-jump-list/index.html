<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>为什么redis一定要用跳跃表来实现有序集合 | 日拱一卒，功不唐捐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="(本文选自《极客时间-算法与数据结构之美》) 对于一个单链表来讲， 即便链表存储的数据是有序的， 如果我们要想在其中查找某个数据， 也只能从头到尾遍历链表。 这样查找到效率很低， 时间复杂度会很高O(n).   那么怎么来提高查找效率呢？ 如果像图中那样， 对链表建立一级“索引“， 查找起来是不是就会更快一些呢？ 每两个结点提取一个结点到上一级， 我们把抽出来的那一级叫作索引或索引层。">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么redis一定要用跳跃表来实现有序集合">
<meta property="og:url" content="http://wanghe4096.github.io/2019/05/13/redis-jump-list/index.html">
<meta property="og:site_name" content="日拱一卒，功不唐捐">
<meta property="og:description" content="(本文选自《极客时间-算法与数据结构之美》) 对于一个单链表来讲， 即便链表存储的数据是有序的， 如果我们要想在其中查找某个数据， 也只能从头到尾遍历链表。 这样查找到效率很低， 时间复杂度会很高O(n).   那么怎么来提高查找效率呢？ 如果像图中那样， 对链表建立一级“索引“， 查找起来是不是就会更快一些呢？ 每两个结点提取一个结点到上一级， 我们把抽出来的那一级叫作索引或索引层。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg">
<meta property="og:updated_time" content="2019-06-05T12:04:09.996Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="为什么redis一定要用跳跃表来实现有序集合">
<meta name="twitter:description" content="(本文选自《极客时间-算法与数据结构之美》) 对于一个单链表来讲， 即便链表存储的数据是有序的， 如果我们要想在其中查找某个数据， 也只能从头到尾遍历链表。 这样查找到效率很低， 时间复杂度会很高O(n).   那么怎么来提高查找效率呢？ 如果像图中那样， 对链表建立一级“索引“， 查找起来是不是就会更快一些呢？ 每两个结点提取一个结点到上一级， 我们把抽出来的那一级叫作索引或索引层。">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg">
  
    <link rel="alternate" href="/atom.xml" title="日拱一卒，功不唐捐" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">日拱一卒，功不唐捐</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wanghe4096.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-redis-jump-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/redis-jump-list/" class="article-date">
  <time datetime="2019-05-12T16:00:00.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      为什么redis一定要用跳跃表来实现有序集合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>(本文选自《极客时间-算法与数据结构之美》)
</code></pre><p>对于一个单链表来讲， 即便链表存储的数据是有序的， 如果我们要想在其中查找某个数据， 也只能从头到尾遍历链表。 这样查找到效率很低， 时间复杂度会很高O(n). </p>
<p><img src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" alt></p>
<p>那么怎么来提高查找效率呢？ 如果像图中那样， 对链表建立一级“索引“， 查找起来是不是就会更快一些呢？ 每两个结点提取一个结点到上一级， 我们把抽出来的那一级叫作索引或索引层。<br><a id="more"></a></p>
<h1 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h1><p>在跳表中查询任意数据的时间复杂度就是O(logn)。</p>
<h1 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h1><p>比起单纯的单链表， 跳表需要存储多级索引， 肯定要消耗更多的存储空间。 但是索引结点只需要存储关键值和几个指针， 并不需要存储对象， 所以当对象比索引结点大很多时， 那索引点用的额外空间就可以忽略了。 </p>
<h1 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h1><p>跳表这个动态的数据结构， 不仅支持查找到操作， 还支持动态的删除和删除操作， 而且插入、删除操作的时间复杂度也是O(logn)</p>
<h1 id="跳表索引的动态更新"><a href="#跳表索引的动态更新" class="headerlink" title="跳表索引的动态更新"></a>跳表索引的动态更新</h1><p>当我们不停的往 跳表中插入数据时， 如果我们不更新索引， 就有可能出现某2个索引结点之间数据非常多的情况。 极端情况下， 跳表还会退化成单链表。 </p>
<p>  <img src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" alt></p>
<p>做为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡， 也就是说， 如果链表中结点多了， 索引结点就相应地增加一些， 避免复杂度退化， 以及查找、插入、删除操作性能下降。 </p>
<p>如果你了解红黑树、AVL树这样的平衡二叉树， 你就知道它们是通过左右旋的方式保持左右子村的大小平衡，而跳表是通过随机函数来维护前面的提到的“平衡性“。</p>
<p>当我们往 跳表中插入数据的时候， 我们可以选择同时将这个数据插入到部分索引层中。如何选 择加入哪睦索引层呢？ </p>
<p>我们通过一个随机函数， 来决定将这个结点插入到哪几级索引中， 比如随机函数生成了值K，  那我们就将这个结占添加到第一级到第K级这K级索引中。 </p>
<p><img src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" alt></p>
<p>随机函数的选择很有讲究， 从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。 </p>
<h1 id="为什么Redis要用跳表来实现有序集合，而不是红黑树"><a href="#为什么Redis要用跳表来实现有序集合，而不是红黑树" class="headerlink" title="为什么Redis要用跳表来实现有序集合，而不是红黑树?"></a>为什么Redis要用跳表来实现有序集合，而不是红黑树?</h1><p>Redis中的有序集合是通过跳表来实现的， 严格点讲，其实还用到了散列表。如果你去查看Redis的开发手册， 就会发现， Redis中的有序集合支持的sy核心操作主要有下面这几个： </p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据(比如查找到[100,356]之间的数据)； </li>
<li>迭代输出有序序列。 </li>
</ul>
<p>其中，插入、删跳表除、查找以及迭代输出有序序列这几个操作， 红黑树也可以完成， 时间复杂度跟跳表是一样的。 但是， 按照区间来查找数据这个操作， 红墨树的效率没有跳表高。 </p>
<p>对于按照区间查找数据这个操作跳表可以做到O(logn)的时间复杂度定位区间的起点， 然后在朱始链表中序往 后遍历就可 了。 这样做非常高效。 </p>
<p>当然， Redis之所以用跳表来实现有序集合， 还有其他原因， 比如跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了， 而简单的就意味着可读性好， 不容易出错。 还有， 跳表更加灵活， 它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 </p>
<p>不过，跳表也不能完全替代红黑树。 因为红黑树比跳表的出现要早一些， 很多编程语言中的Map类型都是通过红黑树来实现的。 我们做业务开发的时候， 直接拿来用就可以了， 不用费劲自己去实现一个红黑村， 但是跳表并没有一个现成的实现， 所以在开发中， 如果你想使用跳表， 必须要自己实现。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wanghe4096.github.io/2019/05/13/redis-jump-list/" data-id="cjythc4m5000dm8fyv8alpxkl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/14/desgin-pattern/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式
        
      </div>
    </a>
  
  
    <a href="/2019/05/12/trie-tree/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前缀树</div>
    </a>
  
</nav>

  
</article>






  <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
  
  
  var gitalk = new Gitalk({
    clientID: '676995b3169b0460f579',
    clientSecret: 'fcc2b957d39e2cf013d9289418e59a6e1740aa14',
    id: "为什么redis一定要用跳跃表来实现有序集合",
    repo: 'wanghe4096.github.io',
    owner: 'wanghe4096',
    admin: 'wanghe4096',
    distractionFreeMode: 'true',
  })

  gitalk.render('gitalk-container')
</script>



</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/02/computer-science-graphic/">计算机知识图普</a>
          </li>
        
          <li>
            <a href="/2019/07/31/study-mongodb/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/30/api-design-guide/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/28/principle-of-ood/">再谈面象对向的设计原则</a>
          </li>
        
          <li>
            <a href="/2019/07/26/principle-of-design/">七条设计原则与应用实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 王贺<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>