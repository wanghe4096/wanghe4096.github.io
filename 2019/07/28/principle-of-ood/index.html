<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>再谈面象对向的设计原则 | 日拱一卒，功不唐捐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 设计模式的六大原则 单一职责原则(SRP) 开闭原则(Open Close Principle) 里氏代换原则(Liskov Substitution Principle) 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则 迪米特法则，又称最少知道原则（Demeter Principle) 合成复用原则(Composite Reuse Prin">
<meta property="og:type" content="article">
<meta property="og:title" content="再谈面象对向的设计原则">
<meta property="og:url" content="http://wanghe4096.github.io/2019/07/28/principle-of-ood/index.html">
<meta property="og:site_name" content="日拱一卒，功不唐捐">
<meta property="og:description" content="1. 设计模式的六大原则 单一职责原则(SRP) 开闭原则(Open Close Principle) 里氏代换原则(Liskov Substitution Principle) 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则 迪米特法则，又称最少知道原则（Demeter Principle) 合成复用原则(Composite Reuse Prin">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://wanghe4096.github.io/images/tech.jpg">
<meta property="og:image" content="http://wanghe4096.github.io/images/Untitled.svg">
<meta property="og:image" content="http://wanghe4096.github.io/images/open-closed.svg">
<meta property="og:updated_time" content="2019-08-02T02:37:00.983Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再谈面象对向的设计原则">
<meta name="twitter:description" content="1. 设计模式的六大原则 单一职责原则(SRP) 开闭原则(Open Close Principle) 里氏代换原则(Liskov Substitution Principle) 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则 迪米特法则，又称最少知道原则（Demeter Principle) 合成复用原则(Composite Reuse Prin">
<meta name="twitter:image" content="http://wanghe4096.github.io/images/tech.jpg">
  
    <link rel="alternate" href="/atom.xml" title="日拱一卒，功不唐捐" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">日拱一卒，功不唐捐</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wanghe4096.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-principle-of-ood" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/28/principle-of-ood/" class="article-date">
  <time datetime="2019-07-27T16:00:00.000Z" itemprop="datePublished">2019-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      再谈面象对向的设计原则
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/tech.jpg" alt></p>
<h1 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1. 设计模式的六大原则"></a>1. 设计模式的六大原则</h1><ol>
<li>单一职责原则(SRP)</li>
<li>开闭原则(Open Close Principle)</li>
<li>里氏代换原则(Liskov Substitution Principle)</li>
<li>依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则</li>
<li>迪米特法则，又称最少知道原则（Demeter Principle)</li>
<li>合成复用原则(Composite Reuse Principle)</li>
<li>重用发布等价原则(REP)</li>
<li>重用发布等价原则(REP)</li>
<li>无环依赖原则（ADP)</li>
<li>稳定依赖原则</li>
<li>稳定抽象原则</li>
</ol>
<a id="more"></a>
<ul>
<li>单一职责原则(SRP)</li>
</ul>
<p>就一个类而言， 应该仅有一个引起它变化的原因。</p>
<ul>
<li>开闭原则(Open Close Principle)</li>
</ul>
<p>软件实体（类、模块、函数等） 应该是可以扩展的，但是不可以修改 。</p>
<p>开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。</p>
<ul>
<li>里氏代换原则(Liskov Substitution Principle)</li>
</ul>
<p>子类型，必须能替换掉他们的基类型。</p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<ul>
<li>依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则</li>
</ul>
<p>抽象不应该依赖于细节。 细节应该依赖于抽象。<br>这个原则是， 使用多个隔离的接口， 比使用简单的接口要好。 它还有另外一个意思， 降低类之间的耦合度。 由此可见，其设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖， 降低耦合。</p>
<ul>
<li>迪米特法则，又称最少知道原则（Demeter Principle)</li>
</ul>
<p>最少知道原则是指： 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<ul>
<li>合成复用原则(Composite Reuse Principle)</li>
</ul>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<ul>
<li>重用发布等价原则(REP)</li>
</ul>
<p>重用的粒度就是发布的粒度。</p>
<ul>
<li>共同封闭原则(CCP)</li>
</ul>
<p>包中所有的类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</p>
<ul>
<li>共同重用原则（CRP)</li>
</ul>
<p>一个包中的所有类应该是共同重用的。 如果重用了包中的一个类， 那么就要重用包中的所有类。</p>
<ul>
<li>无环依赖原则（ADP)</li>
</ul>
<p>在包的依赖关系图中不允许存在环。</p>
<ul>
<li>稳定依赖原则</li>
</ul>
<p>朝着稳定的方向进行依赖。</p>
<ul>
<li>稳定抽象原则</li>
</ul>
<p>包的抽象程度应该和其稳定程度一致。</p>
<h1 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h1><p>就一个类而言， 应该仅有一个引发起它变化的原因。</p>
<p>一个职责都是变化的一个轴线。 当需求变化时，该变化会把 映为类的职责的烃化。 如果一个类承担了多于一个的职责， 那么引起它变化的原因就会有多个。</p>
<p>如果一个类承担的职责过多， 就等于把这些职责耦合在了一起。 一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。 这种耦合会导致脆弱的设计， 当变化发生的时， 设计会遭受到意想不到的破坏。</p>
<h2 id="2-1-什么是职责"><a href="#2-1-什么是职责" class="headerlink" title="2.1. 什么是职责"></a>2.1. 什么是职责</h2><p>在 SRP 中，我们把职责定义为“变化原因“。如果你能够想到多于一个的动机去改变一个类， 那么这个类就是具有多于一个的职责。 有时，我们很难注意到这一点。 我们习惯于以组的形式去考虑职责。 例如下面接口所声明的 4 个函数确实是 modem 所具有的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Modem <span class="keyword">interface</span>&#123;</span><br><span class="line">    Dial(pno <span class="keyword">string</span>)</span><br><span class="line">    Hangup()</span><br><span class="line">    Send(b <span class="keyword">byte</span>)</span><br><span class="line">    Recv()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后， 该接口中却显示出两个职责。 第一个职责是连接管理； 第二个职责是数据通信。 Dial 和 Hangup 函数进行调制解调器的连接处理。 Send 和 Recv 函数进行数据通信。</p>
<p>这两个职责应该被分开吗？ 这依赖于应用程序变化的方式。 如果应用程序的变化会影响连接函数的签名， 那么这个设计就具有僵化性，因为调用 send 和 recv 的类必须要重新编译， 部署的次数常常超过我们希望的次数。 在这种情况下， 这两个职责应被分离。 如下图所示。 这样做避免了客户应用程序和这两个职责耦合在一起。</p>
<p><img src="/images/Untitled.svg" alt></p>
<p>另一方面，如果应用程序的变化方式总是导致这两个职责同时变化， 那么就不必分离它们。 实际上，分离它们就会具有不必要的复杂性。</p>
<p>在此还有一个推论。 变化的轴线仅当变化实际发生时才具有真正的意义。 如果没有征兆。 那么应用 SRP，或者任何其他原则都是不明智的。</p>
<h2 id="2-2-分离耦合的职责"><a href="#2-2-分离耦合的职责" class="headerlink" title="2.2. 分离耦合的职责"></a>2.2. 分离耦合的职责</h2><p>我们注意到上图中， 把两个职责都耦合进了 ModemImplementation 类中。 这不是所希望的，但是或许是必要的。 常常会有一些和硬件或者操作系统的细节有关的原因。 迫使我们把不愿耦合在一起的东西耦合在了一起。 然而， 对于应用的其余部分来说， 通过分离它们的接口我们已经解耦了概念。<br>我们可以把 ModemImplementation 类看作是一个杂凑物，或者是一个瑕疵。 然而，请注意所有的依赖关系都和它无关。谁也不需要依赖于它。 除 main 函数之外， 谁也不需要知道它的存在。</p>
<h2 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3. 结论"></a>2.3. 结论</h2><p>SRP 是所有原则中最简单的原则之一， 也是最难正确运用的原则之一。 我们会自然地把职责结合在一起。 软件设计正要做的许多内容， 就是发现职责并把那些职责相互分离。 事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。</p>
<h1 id="3-开闭原则（OCP"><a href="#3-开闭原则（OCP" class="headerlink" title="3. 开闭原则（OCP)"></a>3. 开闭原则（OCP)</h1><ul>
<li>软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。</li>
</ul>
<p>Ivar Jacobson 曾说过， “任何系统在其生命周其中都会发生变化。 如果我们期望开发出的系统不会在第 1 版后就被抛弃，就必须牢牢地记住这一点。 ” 那么怎样的设计才能面对需求的改变却可以保持相对的稳定， 从而使得系统可以在第一个版本以后不断推出新的版本呢？ Bertrand Meyer 在 1988 年提出的著名的开放——封闭原则（The Open-Closed Principle,简称 OCP)为我们提供了指引。</p>
<p>如果程序中的一处改动就会产生连锁反应， 导致一系列相关模块的改动，那么设计就是僵化的。 OCP 建议我们应该对系统进行重构，这样以后对系统再进行那样的改动时，就不会导致更多的修改。 如果正确地应用 OCP，那么以后再进行同样的改动时，就只需要添加新的代码，而不必改动已经正常运行的代码。</p>
<p>也许， 这看起来像是众所周知的可望而不可及的美好理想——然而，事实上却有一些相对简单并且有效的策略可以帮助接近个理想。</p>
<h2 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1. 描述"></a>3.1. 描述</h2><p>开闭原则的特征：</p>
<ul>
<li>”对于扩展是开放的“<br>这意味着模块的行为是可以扩展的。 当应用的需求改变时， 我们可以对模块进行扩展，使其具有满足那些改变的新行为。 换句话说， 我们可以改变模块的功能。</li>
<li>“对于更改是封闭的”<br>对模块行为进行扩展时， 不必改动模块的源代码或者二进制代码。 模块的二进制可执行版本，无论是可链接的为、DLL 或者 java 的.jar 文件，都无需改动。</li>
</ul>
<p>这两个特征好像是互相矛盾的。 扩展模块行为的通常方式就是修改该模块的源代码。 不允许修改的模块常常都被认为是具有固定的行为。</p>
<p>怎样可能在不改动模块源代码的情况下去更改它的行为呢？ 怎样才能在无需对模块进行改动的情况下就改变它的功能呢？</p>
<h2 id="3-2-关键是抽象"><a href="#3-2-关键是抽象" class="headerlink" title="3.2. 关键是抽象"></a>3.2. 关键是抽象</h2><p>在任何面向对象程序语言中，可以创建出固定却能够描述一组任意个可能行为的抽象体。 这个抽象体就是抽象基类。 而这一组任意个可能的行为则表现为可能的派生类。</p>
<p>模块可以操作一个抽象体。 由于模块依赖于一个固定的抽象体，所以它对于更改可以是关闭的。 同时，通过从这个抽象体派生，也可以扩展此模<br>块的行为。</p>
<p><img src="/images/open-closed.svg" alt><br>如上图， 如果需添加对其他数据库驱动的支持， 我们只需再在实现一个 Driver 接口的类， 就可以完成驱动的扩展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wanghe4096.github.io/2019/07/28/principle-of-ood/" data-id="ck2prxdd6000os0fyy2dlg0ev" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/02/api-design-guide/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/07/26/principle-of-design/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">七条设计原则与应用实践</div>
    </a>
  
</nav>

  
</article>






  <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
  
  
  var gitalk = new Gitalk({
    clientID: '676995b3169b0460f579',
    clientSecret: 'fcc2b957d39e2cf013d9289418e59a6e1740aa14',
    id: "再谈面象对向的设计原则",
    repo: 'wanghe4096.github.io',
    owner: 'wanghe4096',
    admin: 'wanghe4096',
    distractionFreeMode: 'true',
  })

  gitalk.render('gitalk-container')
</script>



</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/08/benchmark-method-2019-11-08/">性能分析与优化的一般套路</a>
          </li>
        
          <li>
            <a href="/2019/08/21/consistent-hashing-algrothym/">一致性哈稀算法</a>
          </li>
        
          <li>
            <a href="/2019/08/05/10-points/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/02/refine/">日拱一卒</a>
          </li>
        
          <li>
            <a href="/2019/08/02/study-mongodb/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 王贺<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>