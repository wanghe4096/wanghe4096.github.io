---
title: 为什么redis一定要用跳跃表来实现有序集合
tags: redis 跳表
---
    (本文选自《极客时间-算法与数据结构之美》)
对于一个单链表来讲， 即便链表存储的数据是有序的， 如果我们要想在其中查找某个数据， 也只能从头到尾遍历链表。 这样查找到效率很低， 时间复杂度会很高O(n). 

![](https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg)


那么怎么来提高查找效率呢？ 如果像图中那样， 对链表建立一级“索引“， 查找起来是不是就会更快一些呢？ 每两个结点提取一个结点到上一级， 我们把抽出来的那一级叫作索引或索引层。 
<!-- more -->

# 用跳表查询到底有多快？ 
在跳表中查询任意数据的时间复杂度就是O(logn)。

# 跳表是不是很浪费内存？ 
比起单纯的单链表， 跳表需要存储多级索引， 肯定要消耗更多的存储空间。 但是索引结点只需要存储关键值和几个指针， 并不需要存储对象， 所以当对象比索引结点大很多时， 那索引点用的额外空间就可以忽略了。 

# 高效的动态插入和删除
跳表这个动态的数据结构， 不仅支持查找到操作， 还支持动态的删除和删除操作， 而且插入、删除操作的时间复杂度也是O(logn)

# 跳表索引的动态更新
当我们不停的往 跳表中插入数据时， 如果我们不更新索引， 就有可能出现某2个索引结点之间数据非常多的情况。 极端情况下， 跳表还会退化成单链表。 

  ![](https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg)

做为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡， 也就是说， 如果链表中结点多了， 索引结点就相应地增加一些， 避免复杂度退化， 以及查找、插入、删除操作性能下降。 

如果你了解红黑树、AVL树这样的平衡二叉树， 你就知道它们是通过左右旋的方式保持左右子村的大小平衡，而跳表是通过随机函数来维护前面的提到的“平衡性“。

当我们往 跳表中插入数据的时候， 我们可以选择同时将这个数据插入到部分索引层中。如何选 择加入哪睦索引层呢？ 
  
我们通过一个随机函数， 来决定将这个结点插入到哪几级索引中， 比如随机函数生成了值K，  那我们就将这个结占添加到第一级到第K级这K级索引中。 
    
![](https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg)

随机函数的选择很有讲究， 从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。 

# 为什么Redis要用跳表来实现有序集合，而不是红黑树? 

Redis中的有序集合是通过跳表来实现的， 严格点讲，其实还用到了散列表。如果你去查看Redis的开发手册， 就会发现， Redis中的有序集合支持的sy核心操作主要有下面这几个： 
- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据(比如查找到[100,356]之间的数据)； 
- 迭代输出有序序列。 

其中，插入、删跳表除、查找以及迭代输出有序序列这几个操作， 红黑树也可以完成， 时间复杂度跟跳表是一样的。 但是， 按照区间来查找数据这个操作， 红墨树的效率没有跳表高。 

对于按照区间查找数据这个操作跳表可以做到O(logn)的时间复杂度定位区间的起点， 然后在朱始链表中序往 后遍历就可 了。 这样做非常高效。 

当然， Redis之所以用跳表来实现有序集合， 还有其他原因， 比如跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了， 而简单的就意味着可读性好， 不容易出错。 还有， 跳表更加灵活， 它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 

不过，跳表也不能完全替代红黑树。 因为红黑树比跳表的出现要早一些， 很多编程语言中的Map类型都是通过红黑树来实现的。 我们做业务开发的时候， 直接拿来用就可以了， 不用费劲自己去实现一个红黑村， 但是跳表并没有一个现成的实现， 所以在开发中， 如果你想使用跳表， 必须要自己实现。 

