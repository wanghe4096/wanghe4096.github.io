---
title: 设计模式
date: 2019-5-14
---

# 设计模式的六大原则

## 开闭原则(Open Close Principle)
开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。 

## 里氏代换原则(Liskov Substitution Principle)
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
## 依赖倒转原则（Dependence  Inversion Principle) 
这个原则是， 使用多个隔离的接口， 比使用简单的接口要好。 它还有另外一个意思， 降低类之间的耦合度。 由此可见，其设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖， 降低耦合。 

## 迪米特法则，又称最少知道原则（Demeter Principle) 
最少知道原则是指： 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 合成复用原则(Composite Reuse Principle)    
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。


<!-- more -->


# 单一职责原则 

## 单一职责的定义
- 应该有且仅有一个原因引起类的变更 
- 单一职责原则要求一个接口只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情

## 单一职责的好处

- 类型复杂性降低，实现什么职责都有清晰明确的定义

- 可读性提高，复杂性降低，自然可读性提高了

- 可维护性提高，可读性提高，那当然更容易维护了

- 变更上起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助

## 单一职责的难处

单一职责的难处是职责的划分。 一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责哪些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？ 这些都需要从实际工作场景中去考虑

### 单一职责的例子
- 非常典型的就是我们目现在的微服务的划分，比如我们按业务职责进行划分
- 日常开发中的接口、类、函数、甚至是变量的职责的定义，都需要遵守单一职责

单一只责适用于接口、类，同时民适用于方法，什么意思呢？一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗

## 单一职责中需要注意

单一职责原则提出一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。 

不能生搬硬套， 犯了意识形态的错误。 

## 我单纯，我快乐

对接接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。 生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。 所以原则是死的， 人是活的，这句话很有道理。 

## 建议
对于单一职责，建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化 



# 里氏代换原则

## 继承的优点
- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 
- 提高代码的重用性； 
- 子类可以形成父类，但又异于父类
- 提高代码的可扩展性，实现父类的方法,很多开源框架都是通过继承父类来完成的
- 提高产品或项目的开放性

## 继承的缺点
- 一定的侵入性。只要继承就必须拥有父类的所有性性和方法
- 降低代码的灵活性。 子类必须拥有父类的性性和方法，让子类自由的世界中多了些约速。这在我们用Go构建系统的时， 采用组合方式更为明显
- 增强了耦合性。 当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构
 
## 引入里氏代换原则
Golang 中是通过使用组合来实现继承，区别于java 中使用extends 字段来实现单一的继承规则，c++则采用多重继承的规则，即和go一样， 一个子类可以继承多个父类。 从整体来看， 利大于弊， 那么怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？ 


## 里氏代换原则的定义

所有引用基类的地方必须能透明的使用其子类的方对象

通俗的讲， 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。 但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 

## 里氏代换对于继承的规范
1. 子类必须完全实现父类的方法
2. 子类可以有自己的特性
3. 覆盖或实现父类的方法时输入参数可以被放大
4. 覆写或实现父类的方法时输出结果可以被缩小


### 子类必须完全实现父类的方法
我们在做系统设计时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏夫换原则。 
作者在2.2节中， 举了一个CS游戏中的例子

### 子类可以有自己的特性
子类当然可以有自己的行为和外观，也不是方法和属性，在Go语言中，似乎只能用过接口组合的方式来实现。 否只能靠类型断言来处理。  但是里氏代换可正着用，而不能反着用。 大子类出现的地方，父类未必就可以胜任。

### 覆盖或实现父类的方法时输入参数可以被放大
方法中的输入参数称为前置条件，这是什么意思呢？大家做过Web Service开发应该知道有一个“契约优先” 也就是先定义WSDL接口，这种设计方法也叫做Design by 
ontract (契约设计) ,与里氏替换原则有着异曲同工之秒。 契约制定了， 也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈。这里还是比较难理解的，

也就是子类代替父类传递到调用者中，子类的方法永远都不会被执行。 这是正确的， 如果你想让子类的方法运行，就必覆写父类的方法。 


### 覆写或实现父类的方法时输出结果可以被缩小 

这是什么意思呢， 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏代换原则就要求S必须小于等于T， 也就是说， 要么S和T是同一个类型，要么S是T的子类，为什么呢？ 分两种情况， 如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 如果是重载， 则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下， 就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的


## 总结
采用里氏代替原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。 在实际项目中， 每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常的完美。 

## 最佳实践
在项目中，采用里氏替换原则时，尽量避免子类的“子性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了， 把子类当作父类来用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。 


