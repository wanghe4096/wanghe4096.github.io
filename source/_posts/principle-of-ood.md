---
title: 再谈面象对向的设计原则
date: 2019-09-28
---

![](/images/tech.jpg)

# 1. 设计模式的六大原则

1. 单一职责原则(SRP)
2. 开闭原则(Open Close Principle)
3. 里氏代换原则(Liskov Substitution Principle)
4. 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则
5. 迪米特法则，又称最少知道原则（Demeter Principle)
6. 合成复用原则(Composite Reuse Principle)
7. 重用发布等价原则(REP)
8. 重用发布等价原则(REP)
9. 无环依赖原则（ADP)
10. 稳定依赖原则
11. 稳定抽象原则

- 单一职责原则(SRP)

就一个类而言， 应该仅有一个引起它变化的原因。

- 开闭原则(Open Close Principle)

软件实体（类、模块、函数等） 应该是可以扩展的，但是不可以修改 。

开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。

- 里氏代换原则(Liskov Substitution Principle)

子类型，必须能替换掉他们的基类型。

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

- 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则

抽象不应该依赖于细节。 细节应该依赖于抽象。
这个原则是， 使用多个隔离的接口， 比使用简单的接口要好。 它还有另外一个意思， 降低类之间的耦合度。 由此可见，其设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖， 降低耦合。

- 迪米特法则，又称最少知道原则（Demeter Principle)

最少知道原则是指： 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

- 合成复用原则(Composite Reuse Principle)

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

- 重用发布等价原则(REP)

重用的粒度就是发布的粒度。

- 共同封闭原则(CCP)

包中所有的类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。

- 共同重用原则（CRP)

一个包中的所有类应该是共同重用的。 如果重用了包中的一个类， 那么就要重用包中的所有类。

- 无环依赖原则（ADP)

在包的依赖关系图中不允许存在环。

- 稳定依赖原则

朝着稳定的方向进行依赖。

- 稳定抽象原则

包的抽象程度应该和其稳定程度一致。

<!-- more -->

# 2. 单一职责原则

就一个类而言， 应该仅有一个引发起它变化的原因。

一个职责都是变化的一个轴线。 当需求变化时，该变化会把 映为类的职责的烃化。 如果一个类承担了多于一个的职责， 那么引起它变化的原因就会有多个。

如果一个类承担的职责过多， 就等于把这些职责耦合在了一起。 一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。 这种耦合会导致脆弱的设计， 当变化发生的时， 设计会遭受到意想不到的破坏。

## 2.1. 什么是职责

在 SRP 中，我们把职责定义为“变化原因“。如果你能够想到多于一个的动机去改变一个类， 那么这个类就是具有多于一个的职责。 有时，我们很难注意到这一点。 我们习惯于以组的形式去考虑职责。 例如下面接口所声明的 4 个函数确实是 modem 所具有的功能。

```go
type Modem interface{
    Dial(pno string)
    Hangup()
    Send(b byte)
    Recv()
}
```

然后， 该接口中却显示出两个职责。 第一个职责是连接管理； 第二个职责是数据通信。 Dial 和 Hangup 函数进行调制解调器的连接处理。 Send 和 Recv 函数进行数据通信。

这两个职责应该被分开吗？ 这依赖于应用程序变化的方式。 如果应用程序的变化会影响连接函数的签名， 那么这个设计就具有僵化性，因为调用 send 和 recv 的类必须要重新编译， 部署的次数常常超过我们希望的次数。 在这种情况下， 这两个职责应被分离。 如下图所示。 这样做避免了客户应用程序和这两个职责耦合在一起。

![](/images/Untitled.svg)

另一方面，如果应用程序的变化方式总是导致这两个职责同时变化， 那么就不必分离它们。 实际上，分离它们就会具有不必要的复杂性。

在此还有一个推论。 变化的轴线仅当变化实际发生时才具有真正的意义。 如果没有征兆。 那么应用 SRP，或者任何其他原则都是不明智的。

## 2.2. 分离耦合的职责

我们注意到上图中， 把两个职责都耦合进了 ModemImplementation 类中。 这不是所希望的，但是或许是必要的。 常常会有一些和硬件或者操作系统的细节有关的原因。 迫使我们把不愿耦合在一起的东西耦合在了一起。 然而， 对于应用的其余部分来说， 通过分离它们的接口我们已经解耦了概念。
我们可以把 ModemImplementation 类看作是一个杂凑物，或者是一个瑕疵。 然而，请注意所有的依赖关系都和它无关。谁也不需要依赖于它。 除 main 函数之外， 谁也不需要知道它的存在。

## 2.3. 结论

SRP 是所有原则中最简单的原则之一， 也是最难正确运用的原则之一。 我们会自然地把职责结合在一起。 软件设计正要做的许多内容， 就是发现职责并把那些职责相互分离。 事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。

# 3. 开闭原则（OCP)

- 软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。

Ivar Jacobson 曾说过， “任何系统在其生命周其中都会发生变化。 如果我们期望开发出的系统不会在第 1 版后就被抛弃，就必须牢牢地记住这一点。 ” 那么怎样的设计才能面对需求的改变却可以保持相对的稳定， 从而使得系统可以在第一个版本以后不断推出新的版本呢？ Bertrand Meyer 在 1988 年提出的著名的开放——封闭原则（The Open-Closed Principle,简称 OCP)为我们提供了指引。

如果程序中的一处改动就会产生连锁反应， 导致一系列相关模块的改动，那么设计就是僵化的。 OCP 建议我们应该对系统进行重构，这样以后对系统再进行那样的改动时，就不会导致更多的修改。 如果正确地应用 OCP，那么以后再进行同样的改动时，就只需要添加新的代码，而不必改动已经正常运行的代码。

也许， 这看起来像是众所周知的可望而不可及的美好理想——然而，事实上却有一些相对简单并且有效的策略可以帮助接近个理想。

## 3.1. 描述

开闭原则的特征：

- ”对于扩展是开放的“
  这意味着模块的行为是可以扩展的。 当应用的需求改变时， 我们可以对模块进行扩展，使其具有满足那些改变的新行为。 换句话说， 我们可以改变模块的功能。
- “对于更改是封闭的”
  对模块行为进行扩展时， 不必改动模块的源代码或者二进制代码。 模块的二进制可执行版本，无论是可链接的为、DLL 或者 java 的.jar 文件，都无需改动。

这两个特征好像是互相矛盾的。 扩展模块行为的通常方式就是修改该模块的源代码。 不允许修改的模块常常都被认为是具有固定的行为。

怎样可能在不改动模块源代码的情况下去更改它的行为呢？ 怎样才能在无需对模块进行改动的情况下就改变它的功能呢？

## 3.2. 关键是抽象

在任何面向对象程序语言中，可以创建出固定却能够描述一组任意个可能行为的抽象体。 这个抽象体就是抽象基类。 而这一组任意个可能的行为则表现为可能的派生类。

模块可以操作一个抽象体。 由于模块依赖于一个固定的抽象体，所以它对于更改可以是关闭的。 同时，通过从这个抽象体派生，也可以扩展此模
块的行为。

![](/images/open-closed.svg)
如上图， 如果需添加对其他数据库驱动的支持， 我们只需再在实现一个 Driver 接口的类， 就可以完成驱动的扩展。
