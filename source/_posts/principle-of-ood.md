---
title: 再谈面象对向的设计原则
date: 2019-09-28
---

# 设计模式的六大原则

## 单一职责原则(SRP)

就一个类而言， 应该仅有一个引起它变化的原因。

## 开闭原则(Open Close Principle)

软件实体（类、模块、函数等） 应该是可以扩展的，但是不可以修改 。

开闭原则的意思是对外扩展开放，对内修改关闭。 在程序需要进行扩展时，不能去修改原有的代码， 实现一个热插拔效。 简而言之，是为了使程序的扩展性好、易于维护和升级。 要达到这样的效果我需要使用接口和类。

## 里氏代换原则(Liskov Substitution Principle)

子类型，必须能替换掉他们的基类型。

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

## 依赖倒转原则（Dependence Inversion Principle),亦称接口隔离原则

抽象不应该依赖于细节。 细节应该依赖于抽象。
这个原则是， 使用多个隔离的接口， 比使用简单的接口要好。 它还有另外一个意思， 降低类之间的耦合度。 由此可见，其设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖， 降低耦合。

## 迪米特法则，又称最少知道原则（Demeter Principle)

最少知道原则是指： 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 合成复用原则(Composite Reuse Principle)

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## 重用发布等价原则(REP)

重用的粒度就是发布的粒度。

## 共同封闭原则(CCP)

包中所有的类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。

## 共同重用原则（CRP)

一个包中的所有类应该是共同重用的。 如果重用了包中的一个类， 那么就要重用包中的所有类。

## 无环依赖原则（ADP)

在包的依赖关系图中不允许存在环。

## 稳定依赖原则

朝着稳定的方向进行依赖。

## 稳定抽象原则

包的抽象程度应该和其稳定程度一致。

<!-- more -->

# 单一职责原则

就一个类而言， 应该仅有一个引发起它变化的原因。

一个职责都是变化的一个轴线。 当需求变化时，该变化会把 映为类的职责的烃化。 如果一个类承担了多于一个的职责， 那么引起它变化的原因就会有多个。

如果一个类承担的职责过多， 就等于把这些职责耦合在了一起。 一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。 这种耦合会导致脆弱的设计， 当变化发生的时， 设计会遭受到意想不到的破坏。

## 什么是职责

在 SRP 中，我们把职责定义为“变化原因“。如果你能够想到多于一个的动机去改变一个类， 那么这个类就是具有多于一个的职责。 有时，我们很难注意到这一点。 我们习惯于以组的形式去考虑职责。 例如下面接口所声明的 4 个函数确实是 modem 所具有的功能。

```go
type Modem interface{
    Dial(pno string)
    Hangup()
    Send(b byte)
    Recv()
}
```

然后， 该接口中却显示出两个职责。 第一个职责是连接管理； 第二个职责是数据通信。 Dial 和 Hangup 函数进行调制解调器的连接处理。 Send 和 Recv 函数进行数据通信。

这两个职责应该被分开吗？ 这依赖于应用程序变化的方式。 如果应用程序的变化会影响连接函数的签名， 那么这个设计就具有僵化性，因为调用 send 和 recv 的类必须要重新编译， 部署的次数常常超过我们希望的次数。 在这种情况下， 这两个职责应被分离。 如下图所示。 这样做避免了客户应用程序和这两个职责耦合在一起。

![](/images/Untitled.svg)

另一方面，如果应用程序的变化方式总是导致这两个职责同时变化， 那么就不必分离它们。 实际上，分离它们就会具有不必要的复杂性。

在此还有一个推论。 变化的轴线仅当变化实际发生时才具有真正的意义。 如果没有征兆。 那么应用 SRP，或者任何其他原则都是不明智的。

## 分离耦合的职责

我们注意到上图中， 把两个职责都耦合进了 ModemImplementation 类中。 这不是所希望的，但是或许是必要的。 常常会有一些和硬件或者操作系统的细节有关的原因。 迫使我们把不愿耦合在一起的东西耦合在了一起。 然而， 对于应用的其余部分来说， 通过分离它们的接口我们已经解耦了概念。
我们可以把 ModemImplementation 类看作是一个杂凑物，或者是一个瑕疵。 然而，请注意所有的依赖关系都和它无关。谁也不需要依赖于它。 除 main 函数之外， 谁也不需要知道它的存在。

## 结论

SRP 是所有原则中最简单的原则之一， 也是最难正确运用的原则之一。 我们会自然地把职责结合在一起。 软件设计正要做的许多内容， 就是发现职责并把那些职责相互分离。 事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。
